# -*- coding: utf-8 -*-

# Copyright (C) 2019 Christoph G. Hoffmann. All rights reserved.

# This file is part of mjoindices

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# Contact: christoph.hoffmann@uni-greifswald.de

"""
This module provides basic functionality to handle u200 data, which is the basic input for the OMI calculation.
"""

from pathlib import Path

import copy
import numpy as np
import scipy
import scipy.interpolate
from matplotlib.figure import Figure
from scipy.io import netcdf
import netCDF4 as netcdf4
import matplotlib.pyplot as plt

import mjoindices.tools as tools


class u200Data:
    """
    This class serves as a container for spatially distributed and temporally resolved u200 data.

    A filled object of this class has to be provided by the user in order to start the OMI calculation.

    :param u200: The u200 data as a 3-dim array. The three dimensions correspond to time, latitude, and longitude, in this
        order.
    :param time: The temporal grid as 1-dim array of :class:`numpy.datetime64` dates.
    :param lat: The latitude grid as 1-dim array.
    :param long: The longitude grid as 1-dim array.
    """

    def __init__(self, u200: np.ndarray, time: np.ndarray, lat: np.ndarray, long: np.ndarray) -> None:
        """
        Initialization of basic variables.
        """
        print("Init u200")
        if u200.shape[0] != time.size:
            raise ValueError('Length of time grid does not fit to first dimension of u200 data cube')
        if u200.shape[1] != lat.size:
            raise ValueError('Length of lat grid does not fit to second dimension of u200 data cube')
        if u200.shape[2] != long.size:
            raise ValueError('Length of long grid does not fit to third dimension of u200 data cube')
        self._u200 = u200.copy()
        self._time = time.copy()
        self._lat = lat.copy()
        self._long = long.copy()

    @property
    def u200(self):
        """
        The u200 data as a 3-dim array. The three dimensions correspond to time, latitude, and longitude, in this
        order.
        """
        return self._u200

    @property
    def time(self):
        """
        The temporal grid as 1-dim array of :class:`numpy.datetime64` dates.
        """
        return self._time

    @property
    def lat(self):
        """
        The latitude grid as 1-dim array.
        """
        return self._lat

    @property
    def long(self):
        """
        The longitude grid as 1-dim array.
        """
        return self._long

    def __eq__(self, other: "u200Data") -> bool:
        """
        Override the default Equals behavior
        """
        return (np.all(self.lat == other.lat)
                and np.all(self.long == other.long)
                and np.all(self.time == other.time)
                and np.all(self.u200 == other.u200))

    def close(self, other: "u200Data") -> bool:
        """
         Checks equality of two :class:`u200Data` objects, but allows for numerical tolerances.

        :param other: The object to compare with.

        :return: Equality of all members considering the default tolerances of :func:`numpy.allclose`
        """
        return (np.allclose(self.lat, other.lat)
                and np.allclose(self.long, other.long)
                and np.allclose(self.time.astype("float"), other.time.astype("float"))  # allclose does not work with datetime64
                and np.allclose(self.u200, other.u200))

    def get_u200_for_date(self, date: np.datetime64) -> np.ndarray:
        """
        Returns the spatially distributed u200 map for a particular date.

        :param date: The date, which hat to be exactly matched by one of the dates in the u200 time grid.

        :return: The excerpt of the u200 data as a 2-dim array. The two dimensions correspond to
            latitude, and longitude, in this order. Returns None if the date is not contained in the u200 time series.
        """
        cand = self.time == date
        if not np.all(cand == False):  # noqa: E712
            return np.squeeze(self.u200[cand, :, :])
        else:
            return None

    def extract_u200_matrix_for_doy_range(self, center_doy: int, window_length: int = 0,
                                         strict_leap_year_treatment: bool = False) -> np.ndarray:
        """
        Extracts the u200 data, which belongs to all DOYs around one center (center_doy +/- windowlength).

        Keep in mind that the u200 time series might span several years. In this case the center DOY is found more than
        once and the respective window in considered for each year.
        Example: 3 full years of data, centerdoy = 20, and window_length = 4 results in 3*(2*4+1) = 27 entries in the
        time axis

        :param center_doy: The center DOY of the window.
        :param window_length: The window length in DOYs on both sides of the center DOY. Hence, if the window is fully
            covered by the data, one gets 2*window_length + 1 entries per year in the result.
        :param strict_leap_year_treatment: see description in :meth:`mjoindices.tools.find_doy_ranges_in_dates`.

        :return: The excerpt of the u200 data as a 3-dim array. The three dimensions correspond to
            time, latitude, and longitude, in this order.
        """
        inds, doys = tools.find_doy_ranges_in_dates(self.time, center_doy, window_length=window_length,
                                                    strict_leap_year_treatment=strict_leap_year_treatment)
        return self.u200[inds, :, :]

    def save_to_npzfile(self, filename: Path) -> None:
        """
        Saves the data arrays contained in the u200Data object to a numpy file.

        :param filename: The full filename.
        """
        np.savez(filename, u200=self.u200, time=self.time, lat=self.lat, long=self.long)


def interpolate_spatial_grid_to_original(u200: u200Data) -> u200Data:
    print("interpolate_spatial_grid_to_original_u200")
    orig_lat = np.arange(-15., 15.1, 2.5)
    orig_long = np.arange(0., 359.9, 2.5)
    return interpolate_spatial_grid(u200, orig_lat, orig_long)


def interpolate_spatial_grid(u200: u200Data, target_lat: np.ndarray, target_long: np.ndarray) -> u200Data:
    """
    Interpolates the u200 data linearly onto the given grids.

    No extrapolation will be done. Instead a :py:class:`ValueError` is raised if the data does not cover the target
    grid.

    Note that no sophisticated resampling is provided here. So, if some kind of averaging, etc., is needed, it should
    be performed by the user himself before injecting the data into the OMI calculation.

    :param u200: The u200 data to resample.
    :param target_lat: The new latitude grid.
    :param target_long: The new longitude grid.

    :return: A new :class:`u200Data` object containing the resampled u200 data.
    """
    print("interpolate_spatial_grid_u200")
    no_days = u200.time.size
    print("no_days:", no_days)
    u200_interpol = np.empty((no_days, target_lat.size, target_long.size))
    for idx in range(0, no_days):
        f = scipy.interpolate.interp2d(u200.long, u200.lat, np.squeeze(u200.u200[idx, :, :]), kind='linear', bounds_error=True)
        u200_interpol[idx, :, :] = f(target_long, target_lat)
    return u200Data(u200_interpol, u200.time, target_lat, target_long)

def restrict_time_coverage_u200(u200_file, time, start: np.datetime64, stop: np.datetime64):
    window_inds = (time >= start) & (time <= stop)
    if np.all(window_inds == False):  # noqa: E712
        raise ValueError("No u200 data within specified period found. Data covers the period")
    else:
        f = netcdf4.Dataset(u200_file, "r")
        #u200_restricted = (f.variables['u'][:].data)[window_inds, :, :]
        u200_restricted = f.variables['u'][window_inds, :, :]
        #print("u200_restricted",u200_restricted)
        return u200_restricted, time[window_inds] 


def load_noaa_interpolated_u200_netcdf4(filename: Path, start: np.datetime64, stop: np.datetime64, plav=False) -> u200Data:

    f = netcdf4.Dataset(filename, "r")
    lat = f.variables['lat'][:].data.copy()
    lon = f.variables['lon'][:].data.copy()
    #u200 = f.variables['u'][:].data.copy()
    hours_since1800 = f.variables['time'][:].data.copy()
    f.close()
    temptime = []
    for item in hours_since1800:
        delta = np.timedelta64(int(item / 24), 'D')
        if plav:
            day = np.datetime64('01-12-30') + delta # plav
        else: 
            day = np.datetime64('1900-01-01') + delta #era5
        temptime.append(day)
    
    print("len_time_before:", len(temptime))
    time = np.array(temptime, dtype=np.datetime64)
    print("load_noaa_interpolated_u200_netcdf4-FLAG4")
    u200_restricted, time_restricted = restrict_time_coverage_u200( filename, time , start, stop)
    print("load_noaa_interpolated_u200_netcdf4-FLAG5")
    print("len_time_after:", len(time_restricted))
    result = u200Data(np.squeeze(u200_restricted), time_restricted, lat, lon)

    return result

#TODO make average  from start to your date only. now data are averaged for all span of years
def get_average_u200_for_day(filename: Path , current_day, current_month , current_year):
    temptime = []
    dates = []
    u200_at_day = []
    f = netcdf4.Dataset(filename, "r")
    hours_since1800 = f.variables['time'][:].data.copy()
    for hours in hours_since1800:
        delta = np.timedelta64(int(hours / 24), 'D')
        doy = np.datetime64('1900-01-01') + delta
        temptime.append(doy)
        year = int(hours/24)/365
        if int(year) == float(year):
            year = int(1900 + year - 1)
            if year < current_year:
                if current_day < 10 and current_month < 10:
                    dates.append(np.datetime64(f'{year}-0{current_month}-0{current_day}'))
                elif current_day < 10:
                    dates.append(np.datetime64(f'{year}-{current_month}-0{current_day}'))
                elif current_month < 10:
                    if (current_year % 4 == 0 or current_year % 4 == 0 and current_year % 100 == 0) and current_day == 29:
                        return 1
                    else:
                        dates.append(np.datetime64(f'{year}-0{current_month}-{current_day}'))
                else:
                    dates.append((f'{year}-{current_month}-{current_day}'))
    time_all = np.array(temptime, dtype=np.datetime64)
    for i in range(len(time_all)-1):
        if time_all[i] in dates:
            u200_at_day.append(f.variables['u'][i])
    f.close()
    average = sum(u200_at_day) / len(dates)
    return average


def get_doys_in_span(u200: u200Data, filename: Path, start:np.datetime64, stop:np.datetime64):
    dates = np.arange(start, stop + np.timedelta64(1, 'D'), dtype='datetime64[D]')
    years = dates.astype('datetime64[Y]').astype(int) + 1970
    months = dates.astype('datetime64[M]').astype(int) % 12 + 1
    days = dates.astype('datetime64[D]') - dates.astype('datetime64[M]') + 1
    for i in range(len(days)):
        print("Find u200 anomaly for date: ", dates[i])
        average = get_average_u200_for_day(filename, days[i].astype(int), months[i].astype(int), years[i])
        get_doy_avarage(u200, average, dates[i])
    return u200Data(u200.u200, u200.time, u200.lat, u200.long)
    
def get_doy_avarage(u200: u200Data, average, doy):
    for i in range(len(u200.time)-1):
        if u200.time[i] == doy:
            u200.u200[i] -= average
            break


def restore_from_npzfile(filename: Path) -> u200Data:
    """
    Loads an :class:`u200Data` object from a numpy file, which has been saved with the function
    :func:`mjoindices.u200_handling.u200Data.save_to_npzfile`

    :param filename: The filename to the .npz file.

    :return: The u200 data.
    """
    with np.load(filename) as data:
        u200 = data["u"]
        time = data["time"]
        lat = data["lat"]
        long = data["long"]
    return u200Data(u200, time, lat, long)


def plot_u200_map_for_date(u200: u200Data, date: np.datetime64) -> Figure:
    """
    Plots a map pf the u200 data for a specific date.

    :param u200: The complete u200 data.
    :param date: The date for which da u200 data should be plotted
        (has to be exactly matched by a date of the u200 time grid).

    :return: The handle to the figure.
    """
    # TODO: Plot underlying map

    mapdata = u200.get_u200_for_date(date)

    if mapdata is not None:
        fig, axs = plt.subplots(1, 1, num="plot_u200_map_for_date", clear=True,
                                figsize=(10, 5), dpi=150, sharex=True, sharey=True)
        plt.subplots_adjust(wspace=0.35, hspace=0.35)

        ax = axs

        c = ax.contourf(u200.long, u200.lat, mapdata)
        fig.colorbar(c, ax=ax, label="u200 [W/m²]")
        ax.set_title("u200")
        ax.set_ylabel("Latitude [°]")
        ax.set_xlabel("Longitude [°]")
    else:
        raise ValueError("No u200 data found for given date.")

    return fig
