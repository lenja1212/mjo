# -*- coding: utf-8 -*-

# Copyright (C) 2019 Christoph G. Hoffmann. All rights reserved.

# This file is part of mjoindices

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# Contact: christoph.hoffmann@uni-greifswald.de

"""
This module provides basic functionality to handle u850 data, which is the basic input for the OMI calculation.
"""

from pathlib import Path

import time
import numpy as np
import scipy
import scipy.interpolate
from matplotlib.figure import Figure
from scipy.io import netcdf
import netCDF4 as netcdf4
import matplotlib.pyplot as plt
import pandas as pd

import tools as tools


class u850Data:
    """
    This class serves as a container for spatially distributed and temporally resolved u850 data.

    A filled object of this class has to be provided by the user in order to start the OMI calculation.

    :param u850: The u850 data as a 3-dim array. The three dimensions correspond to time, latitude, and longitude, in this
        order.
    :param time: The temporal grid as 1-dim array of :class:`numpy.datetime64` dates.
    :param lat: The latitude grid as 1-dim array.
    :param long: The longitude grid as 1-dim array.
    """

    def __init__(self, u850: np.ndarray, time: np.ndarray, lat: np.ndarray, long: np.ndarray) -> None:
        """
        Initialization of basic variables.
        """
        if u850.shape[0] != time.size:
            raise ValueError('Length of time grid does not fit to first dimension of u850 data cube')
        if u850.shape[1] != lat.size:
            raise ValueError('Length of lat grid does not fit to second dimension of u850 data cube')
        if u850.shape[2] != long.size:
            raise ValueError('Length of long grid does not fit to third dimension of u850 data cube')
        self._u850 = u850.copy()
        self._time = time.copy()
        self._lat = lat.copy()
        self._long = long.copy()

    @property
    def u850(self):
        """
        The u850 data as a 3-dim array. The three dimensions correspond to time, latitude, and longitude, in this
        order.
        """
        return self._u850

    @property
    def time(self):
        """
        The temporal grid as 1-dim array of :class:`numpy.datetime64` dates.
        """
        return self._time

    @property
    def lat(self):
        """
        The latitude grid as 1-dim array.
        """
        return self._lat

    @property
    def long(self):
        """
        The longitude grid as 1-dim array.
        """
        return self._long

    def __eq__(self, other: "u850Data") -> bool:
        """
        Override the default Equals behavior
        """
        return (np.all(self.lat == other.lat)
                and np.all(self.long == other.long)
                and np.all(self.time == other.time)
                and np.all(self.u850 == other.u850))

    
def interpolate_spatial_grid_to_original(u850: u850Data) -> u850Data:
    orig_lat = np.arange(-15., 15.1, 2.5)
    orig_long = np.arange(0., 359.9, 2.5)
    return interpolate_spatial_grid(u850, orig_lat, orig_long)

def interpolate_spatial_grid(u850: u850Data, target_lat: np.ndarray, target_long: np.ndarray) -> u850Data:
    print("interpolate_spatial_grid_u850")
    no_days = u850.time.size
    print("no_days:", no_days)
    u850_interpol = np.empty((no_days, target_lat.size, target_long.size))
    for idx in range(0, no_days):
        f = scipy.interpolate.interp2d(u850.long, u850.lat, np.squeeze(u850.u850[idx, :, :]), kind='linear', bounds_error=True)
        u850_interpol[idx, :, :] = f(target_long, target_lat)
    return u850Data(u850_interpol, u850.time, target_lat, target_long)

def restrict_time_coverage_u850(u850_file: Path, time, start: np.datetime64, stop: np.datetime64):
    window_inds = (time >= start) & (time <= stop)
    #f = netcdf4.Dataset(u850_file, "r")
    #for i in range(len(window_inds)):
        #if i >= 7200 and i <= 7628:
           #print("i: ", i, "window_inds[i]: ", window_inds[i])
           #if  window_inds[i] == True:   
            #print("time[i]: ", f.variables['time'][i])
            #print("time[i]: ", (f.variables['time'][:].data)[i] )
            #print("data[i]: ", (f.variables['u'][:].data)[i, :, :])
    if np.all(window_inds == False):  # noqa: E712
        raise ValueError("No u850 data within specified period found.")
    else:
        print(1)
        f = netcdf4.Dataset(u850_file, "r")
        #print("data: ", f.variables['u'][window_inds, :, :])
        #u850_restricted = (f.variables['u'][:].data)[window_inds, :, :]
        u850_restricted = f.variables['u'][window_inds, :, :]
        return u850_restricted, time[window_inds] 

def load_noaa_interpolated_u850_netcdf4(filename: Path, start: np.datetime64, stop: np.datetime64, plav=False) -> u850Data:
    f = netcdf4.Dataset(filename, "r")
    lat = f.variables['lat'][:].data.copy()
    lon = f.variables['lon'][:].data.copy()
    hours_since1800 = f.variables['time'][:].data.copy()
    f.close()
    temptime = []
    for item in hours_since1800:
        delta = np.timedelta64(int(item / 24), 'D')
        if plav:
            day = np.datetime64('01-12-30') + delta # plav
        else: 
            day = np.datetime64('1900-01-01') + delta #era5
        temptime.append(day)
    print("len_time_before:", len(temptime))
    time = np.array(temptime, dtype=np.datetime64)
    print("load_noaa_interpolated_u850_netcdf4-FLAG1")
    u850_restricted, time_restricted = restrict_time_coverage_u850( filename, time , start, stop)
    print("load_noaa_interpolated_u850_netcdf4-FLAG2")
    print("len_time_after:", len(time_restricted))
    result = u850Data(np.squeeze(u850_restricted), time_restricted, lat, lon)

    return result

#TODO do smth with leap years now *-02-29 are just passed 
def get_average_u850_for_day(filename: Path , current_day, current_month , current_year):
    temptime = []
    dates = []
    u850_at_day = []
    f = netcdf4.Dataset(filename, "r")
    hours_since1800 = f.variables['time'][:].data.copy()
    for hours in hours_since1800:
        delta = np.timedelta64(int(hours / 24), 'D')
        doy = np.datetime64('1900-01-01') + delta
        temptime.append(doy)
        year = int(hours/24)/365
        if int(year) == float(year):
            year = int(1900 + year - 1)
            if year < current_year:
                if current_day < 10 and current_month < 10:
                    dates.append(np.datetime64(f'{year}-0{current_month}-0{current_day}'))
                elif current_day < 10:
                    dates.append(np.datetime64(f'{year}-{current_month}-0{current_day}'))
                elif current_month < 10:
                    if (current_year % 4 == 0 or current_year % 4 == 0 and current_year % 100 == 0) and current_day == 29:
                        return 1
                    else:
                        dates.append(np.datetime64(f'{year}-0{current_month}-{current_day}'))
                else:
                    dates.append((f'{year}-{current_month}-{current_day}'))
    #print("dates: ", dates)
    time_all = np.array(temptime, dtype=np.datetime64)
    for i in range(len(time_all)-1):
        if time_all[i] in dates:
            u850_at_day.append(f.variables['u'][i])
    f.close()
    average = sum(u850_at_day) / len(dates)
    #print("average: ", average)
    return average


def get_doys_in_span(u850: u850Data, filename: Path, start:np.datetime64, stop:np.datetime64):
    dates = np.arange(start, stop + np.timedelta64(1, 'D'), dtype='datetime64[D]')
    years = dates.astype('datetime64[Y]').astype(int) + 1970
    months = dates.astype('datetime64[M]').astype(int) % 12 + 1
    days = dates.astype('datetime64[D]') - dates.astype('datetime64[M]') + 1
    for i in range(len(days)):
        print("Find u850 anomaly for date: ", dates[i])
        average = get_average_u850_for_day(filename, days[i].astype(int), months[i].astype(int), years[i])
        get_doy_avarage(u850, average, dates[i])
    return u850Data(u850.u850, u850.time, u850.lat, u850.long)
    
def get_doy_avarage(u850: u850Data, average, doy):
    for i in range(len(u850.time)-1):
        #print("u850.time[i]: ", u850.time[i])
        if u850.time[i] == doy:
            #print("doy: ", doy)
            #print("u850[i]_before: ", u850.u850[i])
            u850.u850[i] -= average
            #print("u850[i]_after: ", u850.u850[i])
            break

#def get_u850_day_anomaly(u850: u850Data, filename: Path, day, month):
    #u850_average = get_average_u850_for_day(filename, day, month)
    #for i in range(len(u850.time)
    
    
    
    
"""
def get_leap_years(filename: Path , day, month):
    leap_years = []
    f = netcdf4.Dataset(filename, "r")
    hours_since1800 = f.variables['time'][:].data.copy()
    for item in hours_since1800:
        if (1900 + int(item/24)/365) % 4 == 0:
            year = int(1900 + (item/24)/365)
            print("item/24: ", int(item/24))
            print("years: ", int(1900 + (item/24)/365))
            leap_years.append(np.datetime64(f'{year}-0{month}-{day}'))
    return leap_years

#from file
def get_average_u850_for_day(filename: Path , day, month):
    temptime = []
    dates = []
    average = []
    f = netcdf4.Dataset(filename, "r")
    hours_since1800 = f.variables['time'][:].data.copy()
    for item in hours_since1800:
        delta = np.timedelta64(int(item / 24), 'D')
        doy = np.datetime64('1900-01-01') + delta
        temptime.append(doy)
        year = int(item/24)/365
        if int(year) == float(year):
            year = int(1900 + year -1)
            dates.append(np.datetime64(f'{year}-0{month}-{day}'))
    time_all = np.array(temptime, dtype=np.datetime64)
    for i in range(len(time_all)-1):
        if time_all[i] in dates:
            average.append(f.variables['u'][i])
    return sum(average) / len(dates)
    
"""
