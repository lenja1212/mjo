from pathlib import Path

import time
import numpy as np
import scipy
import scipy.interpolate
from matplotlib.figure import Figure
from scipy.io import netcdf
import netCDF4 as netcdf4
import matplotlib.pyplot as plt
import pandas as pd

import tools as tools


class sstData:
    """
    This class serves as a container for spatially distributed and temporally resolved sst data.

    A filled object of this class has to be provided by the user in order to start the OMI calculation.

    :param sst: The sst data as a 3-dim array. The three dimensions correspond to time, latitude, and longitude, in this
        order.
    :param time: The temporal grid as 1-dim array of :class:`numpy.datetime64` dates.
    :param lat: The latitude grid as 1-dim array.
    :param long: The longitude grid as 1-dim array.
    """

    def __init__(self, sst: np.ndarray, time: np.ndarray, lat: np.ndarray, long: np.ndarray) -> None:
        """
        Initialization of basic variables.
        """
        if sst.shape[0] != time.size:
            raise ValueError('Length of time grid does not fit to first dimension of sst data cube')
        if sst.shape[1] != lat.size:
            raise ValueError('Length of lat grid does not fit to second dimension of sst data cube')
        if sst.shape[2] != long.size:
            raise ValueError('Length of long grid does not fit to third dimension of sst data cube')
        self._sst = sst.copy()
        self._time = time.copy()
        self._lat = lat.copy()
        self._long = long.copy()

    @property
    def sst(self):
        """
        The sst data as a 3-dim array. The three dimensions correspond to time, latitude, and longitude, in this
        order.
        """
        return self._sst

    @property
    def time(self):
        """
        The temporal grid as 1-dim array of :class:`numpy.datetime64` dates.
        """
        return self._time

    @property
    def lat(self):
        """
        The latitude grid as 1-dim array.
        """
        return self._lat

    @property
    def long(self):
        """
        The longitude grid as 1-dim array.
        """
        return self._long

    def __eq__(self, other: "sstData") -> bool:
        """
        Override the default Equals behavior
        """
        return (np.all(self.lat == other.lat)
                and np.all(self.long == other.long)
                and np.all(self.time == other.time)
                and np.all(self.sst == other.sst))

    
def interpolate_spatial_grid_to_original(sst: sstData) -> sstData:
    orig_lat = np.arange(-15., 15., 2.5)
    orig_long = np.arange(0., 359.9, 2.5)
    return interpolate_spatial_grid(sst, orig_lat, orig_long)

def interpolate_spatial_grid(sst: sstData, target_lat: np.ndarray, target_long: np.ndarray) -> sstData:
    print("interpolate_spatial_grid_sst")
    no_days = sst.time.size
    print("no_days:", no_days)
    sst_interpol = np.empty((no_days, target_lat.size, target_long.size))
    for idx in range(0, no_days):
        f = scipy.interpolate.interp2d(sst.long, sst.lat, np.squeeze(sst.sst[idx, :, :]), kind='linear', bounds_error=True)
        sst_interpol[idx, :, :] = f(target_long, target_lat)
    #for s in range(len(sst.sst)):
        #for i in range(len(sst.sst[s])*len(sst.sst[s][s])):
            #print(sst.sst[s][s][i])
    return sstData(sst_interpol, sst.time, target_lat, target_long)

def restrict_time_coverage_sst(sst_file: Path, time, start: np.datetime64, stop: np.datetime64):
    window_inds = (time >= start) & (time <= stop)
    if np.all(window_inds == False):  # noqa: E712
        raise ValueError("No sst data within specified period found.")
    else:
        print(1)
        f = netcdf4.Dataset(sst_file, "r")
        #print("data: ", f.variables['u'][window_inds, :, :])
        #sst_restricted = (f.variables['u'][:].data)[window_inds, :, :]
        sst_restricted = f.variables['sst'][window_inds, :, :]
        print(" time window_inds", time[window_inds])
        print("len  time window_inds", len(time[window_inds]) )
        return sst_restricted, time[window_inds] 

def load_noaa_interpolated_sst_netcdf4(filename: Path, day_start: np.datetime64, day_end: np.datetime64) -> sstData:
    f = netcdf4.Dataset(filename, "r")
    lat = f.variables['lat'][:].data.copy()
    lon = f.variables['lon'][:].data.copy()
    hours_since1800 = f.variables['time'][:].data.copy()
    
    temptime = []
    for item in hours_since1800:
        delta = np.timedelta64(int(item / 24), 'D')
        day = np.datetime64('1900-01-01') + delta # era5
        temptime.append(day)
    print("len_time_before:", len(temptime))
    time = np.array(temptime, dtype=np.datetime64)
    print("load_noaa_interpolated_sst_netcdf4-FLAG1")
    #sst_restricted, time_restricted = restrict_time_coverage_sst( filename, time , day_start, day_end)
    window_inds = (time >= day_start) & (time <= day_end)
    if np.all(window_inds == False):  # noqa: E712
        raise ValueError("No sst data within specified period found")
    else:
        sst_restricted = f.variables['sst'][window_inds, :, :]
    print("load_noaa_interpolated_sst_netcdf4-FLAG2")
    print("len_time_after:", len(time[window_inds]))
    #print("sst_restricted:", sst_restricted)
    result = sstData(np.squeeze(sst_restricted), time[window_inds], lat, lon)
    f.close()
    return result




#def load_noaa_interpolated_sst_netcdf4(filename: Path, day_start: np.datetime64, day_end: np.datetime64):
    #f = netcdf4.Dataset(filename, "r")
    #hours_since1800 = f.variables['time'][:].data.copy()
    #temptime = []
    #for item in hours_since1800:
        #delta = np.timedelta64(int(item / 24), 'D')
        #day = np.datetime64('1900-01-01') + delta
        #temptime.append(day)
    #time = np.array(temptime, dtype=np.datetime64)
    #window_inds = (time >= day_start) & (time <= day_end)
    #if np.all(window_inds == False):  # noqa: E712
        #raise ValueError("No sst data within specified period found")
    #else:
        #sst_restricted = f.variables['sst'][window_inds, :, :]
    #print("len_time:", time[window_inds])
    #f.close()
    #return sst_restricted, time[window_inds]
